"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/../../packages/shared-lib/api/addresses.ts":
/*!**************************************************!*\
  !*** ../../packages/shared-lib/api/addresses.ts ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAddress: function() { return /* binding */ createAddress; },\n/* harmony export */   deleteAddress: function() { return /* binding */ deleteAddress; },\n/* harmony export */   ensureDefaultAddress: function() { return /* binding */ ensureDefaultAddress; },\n/* harmony export */   getAddressById: function() { return /* binding */ getAddressById; },\n/* harmony export */   getAddresses: function() { return /* binding */ getAddresses; },\n/* harmony export */   getDefaultAddress: function() { return /* binding */ getDefaultAddress; },\n/* harmony export */   setDefaultAddress: function() { return /* binding */ setDefaultAddress; },\n/* harmony export */   updateAddress: function() { return /* binding */ updateAddress; }\n/* harmony export */ });\n/* harmony import */ var _repo_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @repo/database */ \"(app-pages-browser)/../../packages/database/index.ts\");\n\n/**\n * Get all addresses for a user\n */ async function getAddresses(userId) {\n    console.log(\"[getAddresses] Fetching addresses for userId:\", userId);\n    const { data, error } = await _repo_database__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"addresses\").select(\"*\").eq(\"user_id\", userId).is(\"archived_at\", null).order(\"is_default\", {\n        ascending: false\n    }).order(\"created_at\", {\n        ascending: false\n    });\n    if (error) {\n        console.error(\"[getAddresses] Error fetching addresses:\", error);\n        throw new Error(\"Failed to fetch addresses\");\n    }\n    console.log(\"[getAddresses] Found\", (data === null || data === void 0 ? void 0 : data.length) || 0, \"addresses\");\n    return data || [];\n}\n/**\n * Get default address for a user\n */ async function getDefaultAddress(userId) {\n    const { data, error } = await _repo_database__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"addresses\").select(\"*\").eq(\"user_id\", userId).eq(\"is_default\", true).single();\n    if (error) {\n        if (error.code === \"PGRST116\") {\n            // No default address found\n            return null;\n        }\n        console.error(\"Error fetching default address:\", error);\n        throw new Error(\"Failed to fetch default address\");\n    }\n    return data;\n}\n/**\n * Get a specific address by ID\n */ async function getAddressById(addressId) {\n    const { data, error } = await _repo_database__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"addresses\").select(\"*\").eq(\"id\", addressId).single();\n    if (error) {\n        console.error(\"Error fetching address:\", error);\n        return null;\n    }\n    return data;\n}\n/**\n * Create a new address\n */ async function createAddress(userId, addressData) {\n    console.log(\"[createAddress] Starting with userId:\", userId);\n    console.log(\"[createAddress] Address data:\", addressData);\n    // If this is set as default, unset other defaults first\n    if (addressData.is_default) {\n        console.log(\"[createAddress] Unsetting other default addresses...\");\n        await unsetDefaultAddresses(userId);\n    }\n    const insertData = {\n        user_id: userId,\n        ...addressData,\n        updated_at: new Date().toISOString()\n    };\n    console.log(\"[createAddress] Inserting data:\", insertData);\n    const { data, error } = await _repo_database__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"addresses\").insert(insertData).select().single();\n    if (error) {\n        console.error(\"[createAddress] Error creating address:\", error);\n        console.error(\"[createAddress] Error details:\", JSON.stringify(error, null, 2));\n        throw new Error(\"Failed to create address: \".concat(error.message));\n    }\n    console.log(\"[createAddress] Successfully created address:\", data);\n    return data;\n}\n/**\n * Update an existing address\n */ async function updateAddress(addressId, addressData) {\n    // Get the address to find its user_id\n    const existingAddress = await getAddressById(addressId);\n    if (!existingAddress) {\n        throw new Error(\"Address not found\");\n    }\n    // If setting as default, unset other defaults first\n    if (addressData.is_default) {\n        await unsetDefaultAddresses(existingAddress.user_id);\n    }\n    const { data, error } = await _repo_database__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"addresses\").update({\n        ...addressData,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", addressId).select().single();\n    if (error) {\n        console.error(\"Error updating address:\", error);\n        throw new Error(\"Failed to update address\");\n    }\n    return data;\n}\n/**\n * Delete an address\n */ async function deleteAddress(addressId) {\n    const { error } = await _repo_database__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"addresses\").delete().eq(\"id\", addressId);\n    if (error) {\n        console.error(\"Error deleting address:\", error);\n        throw new Error(\"Failed to delete address\");\n    }\n}\n/**\n * Set an address as default (and unset others)\n */ async function setDefaultAddress(userId, addressId) {\n    // First, unset all defaults for this user\n    await unsetDefaultAddresses(userId);\n    // Then set the new default\n    const { error } = await _repo_database__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"addresses\").update({\n        is_default: true,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", addressId).eq(\"user_id\", userId);\n    if (error) {\n        console.error(\"Error setting default address:\", error);\n        throw new Error(\"Failed to set default address\");\n    }\n}\n/**\n * Unset all default addresses for a user (internal helper)\n */ async function unsetDefaultAddresses(userId) {\n    const { error } = await _repo_database__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"addresses\").update({\n        is_default: false\n    }).eq(\"user_id\", userId).eq(\"is_default\", true);\n    if (error) {\n        console.error(\"Error unsetting default addresses:\", error);\n    // Don't throw here, as this is a helper function\n    }\n}\n/**\n * Ensure user has at least one default address\n * If no default exists, set the first address as default\n */ async function ensureDefaultAddress(userId) {\n    const addresses = await getAddresses(userId);\n    if (addresses.length === 0) {\n        return; // No addresses to set as default\n    }\n    const hasDefault = addresses.some((addr)=>addr.is_default);\n    if (!hasDefault) {\n        // Set the first address as default\n        await setDefaultAddress(userId, addresses[0].id);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9wYWNrYWdlcy9zaGFyZWQtbGliL2FwaS9hZGRyZXNzZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBDO0FBZ0MxQzs7Q0FFQyxHQUNNLGVBQWVDLGFBQWFDLE1BQWM7SUFDL0NDLFFBQVFDLEdBQUcsQ0FBQyxpREFBaURGO0lBRTdELE1BQU0sRUFBRUcsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNTixvREFBUUEsQ0FDbkNPLElBQUksQ0FBQyxhQUNMQyxNQUFNLENBQUMsS0FDUEMsRUFBRSxDQUFDLFdBQVdQLFFBQ2RRLEVBQUUsQ0FBQyxlQUFlLE1BQ2xCQyxLQUFLLENBQUMsY0FBYztRQUFFQyxXQUFXO0lBQU0sR0FDdkNELEtBQUssQ0FBQyxjQUFjO1FBQUVDLFdBQVc7SUFBTTtJQUUxQyxJQUFJTixPQUFPO1FBQ1RILFFBQVFHLEtBQUssQ0FBQyw0Q0FBNENBO1FBQzFELE1BQU0sSUFBSU8sTUFBTTtJQUNsQjtJQUVBVixRQUFRQyxHQUFHLENBQUMsd0JBQXdCQyxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1TLE1BQU0sS0FBSSxHQUFHO0lBQ3ZELE9BQU9ULFFBQVEsRUFBRTtBQUNuQjtBQUVBOztDQUVDLEdBQ00sZUFBZVUsa0JBQWtCYixNQUFjO0lBQ3BELE1BQU0sRUFBRUcsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNTixvREFBUUEsQ0FDbkNPLElBQUksQ0FBQyxhQUNMQyxNQUFNLENBQUMsS0FDUEMsRUFBRSxDQUFDLFdBQVdQLFFBQ2RPLEVBQUUsQ0FBQyxjQUFjLE1BQ2pCTyxNQUFNO0lBRVQsSUFBSVYsT0FBTztRQUNULElBQUlBLE1BQU1XLElBQUksS0FBSyxZQUFZO1lBQzdCLDJCQUEyQjtZQUMzQixPQUFPO1FBQ1Q7UUFDQWQsUUFBUUcsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDakQsTUFBTSxJQUFJTyxNQUFNO0lBQ2xCO0lBRUEsT0FBT1I7QUFDVDtBQUVBOztD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R0FDaEVuQixFQUFFLENBQUMsTUFBTVUsV0FDVFYsRUFBRSxDQUFDLFdBQVdQO0lBRWpCLElBQUlJLE9BQU87UUFDVEgsUUFBUUcsS0FBSyxDQUFDLGtDQUFrQ0E7UUFDaEQsTUFBTSxJQUFJTyxNQUFNO0lBQ2xCO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELGVBQWVVLHNCQUFzQnJCLE1BQWM7SUFDakQsTUFBTSxFQUFFSSxLQUFLLEVBQUUsR0FBRyxNQUFNTixvREFBUUEsQ0FDN0JPLElBQUksQ0FBQyxhQUNMNEIsTUFBTSxDQUFDO1FBQUViLFlBQVk7SUFBTSxHQUMzQmIsRUFBRSxDQUFDLFdBQVdQLFFBQ2RPLEVBQUUsQ0FBQyxjQUFjO0lBRXBCLElBQUlILE9BQU87UUFDVEgsUUFBUUcsS0FBSyxDQUFDLHNDQUFzQ0E7SUFDcEQsaURBQWlEO0lBQ25EO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxlQUFlaUMscUJBQXFCckMsTUFBYztJQUN2RCxNQUFNc0MsWUFBWSxNQUFNdkMsYUFBYUM7SUFFckMsSUFBSXNDLFVBQVUxQixNQUFNLEtBQUssR0FBRztRQUMxQixRQUFRLGlDQUFpQztJQUMzQztJQUVBLE1BQU0yQixhQUFhRCxVQUFVRSxJQUFJLENBQUNDLENBQUFBLE9BQVFBLEtBQUtyQixVQUFVO0lBRXpELElBQUksQ0FBQ21CLFlBQVk7UUFDZixtQ0FBbUM7UUFDbkMsTUFBTUgsa0JBQWtCcEMsUUFBUXNDLFNBQVMsQ0FBQyxFQUFFLENBQUNJLEVBQUU7SUFDakQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vcGFja2FnZXMvc2hhcmVkLWxpYi9hcGkvYWRkcmVzc2VzLnRzPzIwNmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAcmVwby9kYXRhYmFzZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRkcmVzcyB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJfaWQ6IHN0cmluZztcbiAgdHlwZTogJ3NoaXBwaW5nJyB8ICdiaWxsaW5nJyB8ICdib3RoJztcbiAgaXNfZGVmYXVsdDogYm9vbGVhbjtcbiAgZnVsbF9uYW1lOiBzdHJpbmc7XG4gIHBob25lOiBzdHJpbmc7IC8vIERhdGFiYXNlIGNvbHVtbiBuYW1lXG4gIGFkZHJlc3NfbGluZTE6IHN0cmluZztcbiAgYWRkcmVzc19saW5lMj86IHN0cmluZyB8IG51bGw7XG4gIGNpdHk6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZzsgLy8gRGF0YWJhc2UgY29sdW1uIG5hbWVcbiAgcG9zdGFsX2NvZGU6IHN0cmluZztcbiAgY291bnRyeTogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGRyZXNzRm9ybURhdGEge1xuICB0eXBlOiAnc2hpcHBpbmcnIHwgJ2JpbGxpbmcnIHwgJ2JvdGgnO1xuICBpc19kZWZhdWx0OiBib29sZWFuO1xuICBmdWxsX25hbWU6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZzsgLy8gTWF0Y2ggZGF0YWJhc2UgY29sdW1uXG4gIGFkZHJlc3NfbGluZTE6IHN0cmluZztcbiAgYWRkcmVzc19saW5lMj86IHN0cmluZztcbiAgY2l0eTogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nOyAvLyBNYXRjaCBkYXRhYmFzZSBjb2x1bW5cbiAgcG9zdGFsX2NvZGU6IHN0cmluZztcbiAgY291bnRyeTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEdldCBhbGwgYWRkcmVzc2VzIGZvciBhIHVzZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFkZHJlc3Nlcyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8QWRkcmVzc1tdPiB7XG4gIGNvbnNvbGUubG9nKCdbZ2V0QWRkcmVzc2VzXSBGZXRjaGluZyBhZGRyZXNzZXMgZm9yIHVzZXJJZDonLCB1c2VySWQpO1xuICBcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnYWRkcmVzc2VzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgLmlzKCdhcmNoaXZlZF9hdCcsIG51bGwpXG4gICAgLm9yZGVyKCdpc19kZWZhdWx0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tnZXRBZGRyZXNzZXNdIEVycm9yIGZldGNoaW5nIGFkZHJlc3NlczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYWRkcmVzc2VzJyk7XG4gIH1cblxuICBjb25zb2xlLmxvZygnW2dldEFkZHJlc3Nlc10gRm91bmQnLCBkYXRhPy5sZW5ndGggfHwgMCwgJ2FkZHJlc3NlcycpO1xuICByZXR1cm4gZGF0YSB8fCBbXTtcbn1cblxuLyoqXG4gKiBHZXQgZGVmYXVsdCBhZGRyZXNzIGZvciBhIHVzZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlZmF1bHRBZGRyZXNzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxBZGRyZXNzIHwgbnVsbD4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdhZGRyZXNzZXMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAuZXEoJ2lzX2RlZmF1bHQnLCB0cnVlKVxuICAgIC5zaW5nbGUoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2Jykge1xuICAgICAgLy8gTm8gZGVmYXVsdCBhZGRyZXNzIGZvdW5kXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZGVmYXVsdCBhZGRyZXNzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBkZWZhdWx0IGFkZHJlc3MnKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCBhIHNwZWNpZmljIGFkZHJlc3MgYnkgSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFkZHJlc3NCeUlkKGFkZHJlc3NJZDogc3RyaW5nKTogUHJvbWlzZTxBZGRyZXNzIHwgbnVsbD4ge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdhZGRyZXNzZXMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaWQnLCBhZGRyZXNzSWQpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFkZHJlc3M6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGFkZHJlc3NcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFkZHJlc3MoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBhZGRyZXNzRGF0YTogQWRkcmVzc0Zvcm1EYXRhXG4pOiBQcm9taXNlPEFkZHJlc3M+IHtcbiAgY29uc29sZS5sb2coJ1tjcmVhdGVBZGRyZXNzXSBTdGFydGluZyB3aXRoIHVzZXJJZDonLCB1c2VySWQpO1xuICBjb25zb2xlLmxvZygnW2NyZWF0ZUFkZHJlc3NdIEFkZHJlc3MgZGF0YTonLCBhZGRyZXNzRGF0YSk7XG4gIFxuICAvLyBJZiB0aGlzIGlzIHNldCBhcyBkZWZhdWx0LCB1bnNldCBvdGhlciBkZWZhdWx0cyBmaXJzdFxuICBpZiAoYWRkcmVzc0RhdGEuaXNfZGVmYXVsdCkge1xuICAgIGNvbnNvbGUubG9nKCdbY3JlYXRlQWRkcmVzc10gVW5zZXR0aW5nIG90aGVyIGRlZmF1bHQgYWRkcmVzc2VzLi4uJyk7XG4gICAgYXdhaXQgdW5zZXREZWZhdWx0QWRkcmVzc2VzKHVzZXJJZCk7XG4gIH1cblxuICBjb25zdCBpbnNlcnREYXRhID0ge1xuICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAuLi5hZGRyZXNzRGF0YSxcbiAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIH07XG4gIFxuICBjb25zb2xlLmxvZygnW2NyZWF0ZUFkZHJlc3NdIEluc2VydGluZyBkYXRhOicsIGluc2VydERhdGEpO1xuXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2FkZHJlc3NlcycpXG4gICAgLmluc2VydChpbnNlcnREYXRhKVxuICAgIC5zZWxlY3QoKVxuICAgIC5zaW5nbGUoKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbY3JlYXRlQWRkcmVzc10gRXJyb3IgY3JlYXRpbmcgYWRkcmVzczonLCBlcnJvcik7XG4gICAgY29uc29sZS5lcnJvcignW2NyZWF0ZUFkZHJlc3NdIEVycm9yIGRldGFpbHM6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgYWRkcmVzczogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ1tjcmVhdGVBZGRyZXNzXSBTdWNjZXNzZnVsbHkgY3JlYXRlZCBhZGRyZXNzOicsIGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgYWRkcmVzc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQWRkcmVzcyhcbiAgYWRkcmVzc0lkOiBzdHJpbmcsXG4gIGFkZHJlc3NEYXRhOiBQYXJ0aWFsPEFkZHJlc3NGb3JtRGF0YT5cbik6IFByb21pc2U8QWRkcmVzcz4ge1xuICAvLyBHZXQgdGhlIGFkZHJlc3MgdG8gZmluZCBpdHMgdXNlcl9pZFxuICBjb25zdCBleGlzdGluZ0FkZHJlc3MgPSBhd2FpdCBnZXRBZGRyZXNzQnlJZChhZGRyZXNzSWQpO1xuICBpZiAoIWV4aXN0aW5nQWRkcmVzcykge1xuICAgIHRocm93IG5ldyBFcnJvcignQWRkcmVzcyBub3QgZm91bmQnKTtcbiAgfVxuXG4gIC8vIElmIHNldHRpbmcgYXMgZGVmYXVsdCwgdW5zZXQgb3RoZXIgZGVmYXVsdHMgZmlyc3RcbiAgaWYgKGFkZHJlc3NEYXRhLmlzX2RlZmF1bHQpIHtcbiAgICBhd2FpdCB1bnNldERlZmF1bHRBZGRyZXNzZXMoZXhpc3RpbmdBZGRyZXNzLnVzZXJfaWQpO1xuICB9XG5cbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnYWRkcmVzc2VzJylcbiAgICAudXBkYXRlKHtcbiAgICAgIC4uLmFkZHJlc3NEYXRhLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pXG4gICAgLmVxKCdpZCcsIGFkZHJlc3NJZClcbiAgICAuc2VsZWN0KClcbiAgICAuc2luZ2xlKCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgYWRkcmVzczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlbGV0ZSBhbiBhZGRyZXNzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVBZGRyZXNzKGFkZHJlc3NJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2FkZHJlc3NlcycpXG4gICAgLmRlbGV0ZSgpXG4gICAgLmVxKCdpZCcsIGFkZHJlc3NJZCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgYWRkcmVzczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGFkZHJlc3MnKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhbiBhZGRyZXNzIGFzIGRlZmF1bHQgKGFuZCB1bnNldCBvdGhlcnMpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXREZWZhdWx0QWRkcmVzcyh1c2VySWQ6IHN0cmluZywgYWRkcmVzc0lkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gRmlyc3QsIHVuc2V0IGFsbCBkZWZhdWx0cyBmb3IgdGhpcyB1c2VyXG4gIGF3YWl0IHVuc2V0RGVmYXVsdEFkZHJlc3Nlcyh1c2VySWQpO1xuXG4gIC8vIFRoZW4gc2V0IHRoZSBuZXcgZGVmYXVsdFxuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdhZGRyZXNzZXMnKVxuICAgIC51cGRhdGUoeyBpc19kZWZhdWx0OiB0cnVlLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcbiAgICAuZXEoJ2lkJywgYWRkcmVzc0lkKVxuICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2V0dGluZyBkZWZhdWx0IGFkZHJlc3M6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNldCBkZWZhdWx0IGFkZHJlc3MnKTtcbiAgfVxufVxuXG4vKipcbiAqIFVuc2V0IGFsbCBkZWZhdWx0IGFkZHJlc3NlcyBmb3IgYSB1c2VyIChpbnRlcm5hbCBoZWxwZXIpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVuc2V0RGVmYXVsdEFkZHJlc3Nlcyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdhZGRyZXNzZXMnKVxuICAgIC51cGRhdGUoeyBpc19kZWZhdWx0OiBmYWxzZSB9KVxuICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAuZXEoJ2lzX2RlZmF1bHQnLCB0cnVlKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1bnNldHRpbmcgZGVmYXVsdCBhZGRyZXNzZXM6JywgZXJyb3IpO1xuICAgIC8vIERvbid0IHRocm93IGhlcmUsIGFzIHRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb25cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSB1c2VyIGhhcyBhdCBsZWFzdCBvbmUgZGVmYXVsdCBhZGRyZXNzXG4gKiBJZiBubyBkZWZhdWx0IGV4aXN0cywgc2V0IHRoZSBmaXJzdCBhZGRyZXNzIGFzIGRlZmF1bHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZURlZmF1bHRBZGRyZXNzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IGdldEFkZHJlc3Nlcyh1c2VySWQpO1xuICBcbiAgaWYgKGFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47IC8vIE5vIGFkZHJlc3NlcyB0byBzZXQgYXMgZGVmYXVsdFxuICB9XG5cbiAgY29uc3QgaGFzRGVmYXVsdCA9IGFkZHJlc3Nlcy5zb21lKGFkZHIgPT4gYWRkci5pc19kZWZhdWx0KTtcbiAgXG4gIGlmICghaGFzRGVmYXVsdCkge1xuICAgIC8vIFNldCB0aGUgZmlyc3QgYWRkcmVzcyBhcyBkZWZhdWx0XG4gICAgYXdhaXQgc2V0RGVmYXVsdEFkZHJlc3ModXNlcklkLCBhZGRyZXNzZXNbMF0uaWQpO1xuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsImdldEFkZHJlc3NlcyIsInVzZXJJZCIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJpcyIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiRXJyb3IiLCJsZW5ndGgiLCJnZXREZWZhdWx0QWRkcmVzcyIsInNpbmdsZSIsImNvZGUiLCJnZXRBZGRyZXNzQnlJZCIsImFkZHJlc3NJZCIsImNyZWF0ZUFkZHJlc3MiLCJhZGRyZXNzRGF0YSIsImlzX2RlZmF1bHQiLCJ1bnNldERlZmF1bHRBZGRyZXNzZXMiLCJpbnNlcnREYXRhIiwidXNlcl9pZCIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJpbnNlcnQiLCJKU09OIiwic3RyaW5naWZ5IiwibWVzc2FnZSIsInVwZGF0ZUFkZHJlc3MiLCJleGlzdGluZ0FkZHJlc3MiLCJ1cGRhdGUiLCJkZWxldGVBZGRyZXNzIiwiZGVsZXRlIiwic2V0RGVmYXVsdEFkZHJlc3MiLCJlbnN1cmVEZWZhdWx0QWRkcmVzcyIsImFkZHJlc3NlcyIsImhhc0RlZmF1bHQiLCJzb21lIiwiYWRkciIsImlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../packages/shared-lib/api/addresses.ts\n"));

/***/ })

});